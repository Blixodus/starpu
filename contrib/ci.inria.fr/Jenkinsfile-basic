#!groovy

def statusHasChanged = false

pipeline
{
	agent none

	// Trigger the build
	triggers {
		// Poll gitlab explicitly every 15mn
		pollSCM('00-59/15 * * * *')
	}

	stages
	{
		stage('Tarball')
		{
			steps
			{
				node('autotools')
				{
					checkout scm
					sh 'contrib/ci.inria.fr/job-0-tarball.sh'
					script
					{
					       env.tarballgz = sh (script: 'ls *.tar.gz', returnStdout: true).trim()
					}
					stash includes: "${env.tarballgz}", name: 'tarballgz'
					stash includes: "starpu.pdf", name: 'doc'
					// Stash those scripts because they are not in make dist
					dir('contrib/ci.inria.fr')
					{
						stash includes: "job-1-check.sh", name: 'script-unix-check'
					}
					archiveArtifacts artifacts: "${env.tarballgz},starpu.pdf", fingerprint: true, onlyIfSuccessful: true
					deleteDir()

				}
			}
		}
		stage('Check')
		{
			steps
			{
				script
				{
					labelToSelect = 'unix'
					listOfNodeNames = jenkins.model.Jenkins.instance.nodes.collect
					{
						node -> node.getLabelString().contains(labelToSelect) ? node.name : null
					}
					listOfNodeNames.removeAll(Collections.singleton(null))

					def p = listOfNodeNames.collectEntries
					{
						[ (it):
						{
							node(it)
							{
								dir('check-unix')
								{
									unstash 'tarballgz'
									unstash 'script-unix-check'
									sh 'chmod 755 job-1-check.sh && ./job-1-check.sh'
									deleteDir()
								}
							}
						}
					]}
					parallel p;
				}
			}
		}
	}

	post
	{
		// hooks are called in order: always, changed, aborted, failure, success, unstable
		changed
		{
			echo "Build status has changed."
			script
			{

				statusHasChanged = true
			}
		}
		success
		{
			echo "Build success."
			// email when changed to success
			script
			{
				if (statusHasChanged)
				{
					emailext(body: '${DEFAULT_CONTENT}',
						 subject: '${DEFAULT_SUBJECT}',
						 replyTo: '$DEFAULT_REPLYTO',
						 to: '$DEFAULT_RECIPIENTS',
						 recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']])
				}
			}
		}
		failure
		{
			echo "Build failure."
			// always email on failure
			emailext(body: '${DEFAULT_CONTENT}',
				 subject: '${DEFAULT_SUBJECT}',
				 replyTo: '$DEFAULT_REPLYTO',
				 to: '$DEFAULT_RECIPIENTS',
				 recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']])
		}
	}
}
