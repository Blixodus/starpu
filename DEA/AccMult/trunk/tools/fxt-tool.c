#include "fxt-tool.h"

event_list_t *events[MAXWORKERS];
workq_list_t *taskq;
char *worker_name[MAXWORKERS];

fxt_t fut;
struct fxt_ev_64 ev;

unsigned first_event = 1;
uint64_t start_time = 0;
uint64_t end_time = 0;

unsigned nworkers = 0;

void handle_new_worker(void)
{

	char *str = malloc(20*sizeof(char));
	
	strcpy(str, "unknown");

	switch (ev.param[0]) {
		case FUT_APPS_KEY:
			str = "apps";
			break;
		case FUT_CORE_KEY:
			str = "core";
			break;
		case FUT_CUDA_KEY:
			str = "cuda";
			break;
		case FUT_CUBLAS_KEY:
			str = "cublas";
			break;
	}

//	fprintf(stderr, "new %s worker (tid = %d)\n", str, ev.param[1]);

	
	char *tidstr = malloc(16*sizeof(char));
	sprintf(tidstr, "%ld", ev.param[1]);

	/* create a new key in the htable */
	unsigned workerid = nworkers++;
	ENTRY item;
		item.key = tidstr;
		item.data = (int *)(workerid);

	ENTRY *res;
	res = hsearch(item, FIND);

	worker_name[workerid] = str;

	/* only register a thread once */
	ASSERT(res == NULL);

	res = hsearch(item, ENTER);
	ASSERT(res);

	events[workerid] = event_list_new();
}

int find_workder_id(unsigned long tid)
{
	char tidstr[16];
	sprintf(tidstr, "%ld", tid);

	ENTRY item;
		item.key = tidstr;
		item.data = NULL;
	ENTRY *res;
	res = hsearch(item, FIND);
	ASSERT(res);

	return (int)(res->data);
}

void handle_start_codelet_body(void)
{

	//fprintf(stderr, "start codelet %p on tid %d\n", (void *)ev.param[0], ev.param[1]);

	int worker;
	worker = find_workder_id(ev.param[1]);
//	printf("-> worker %d\n", worker);

	event_t e = event_new();
	e->time =  ev.time;
	e->mode = WORKING;
	event_list_push_back(events[worker], e);

	end_time = MAX(end_time, ev.time);
}

void handle_end_codelet_body(void)
{
	//fprintf(stderr, "end codelet %p on tid %d\n", (void *)ev.param[0], ev.param[1]);

	int worker;
	worker = find_workder_id(ev.param[1]);
//	printf("<- worker %d\n", worker);

	event_t e = event_new();
	e->time =  ev.time;
	e->mode = IDLE;
	event_list_push_back(events[worker], e);

	end_time = MAX(end_time, ev.time);
}

int maxq_size = 0;
int curq_size = 0;

void handle_job_push(void)
{
	curq_size++;

	maxq_size = MAX(maxq_size, curq_size);

	workq_t e = workq_new();
	e->time =  ev.time;
	e->diff =  +1;
	e->current_size = curq_size;

	workq_list_push_back(taskq, e);
}

void handle_job_pop(void)
{
	curq_size--;

	workq_t e = workq_new();
	e->time =  ev.time;
	e->diff =  -1;
	e->current_size = curq_size;

	workq_list_push_back(taskq, e);
}

void generate_flash_output()
{
	flash_engine_init();
	flash_engine_generate_output(events, taskq, worker_name, nworkers, maxq_size, start_time, end_time, "toto.swf");
}

void generate_gnuplot_output()
{
	FILE *output;
	output = fopen("data", "w+");
	ASSERT(output);
	
	unsigned linesize;
	unsigned maxline = 0;

	unsigned worker;
	for (worker = 0; worker < nworkers; worker++)
	{
		linesize = 0;

		event_itor_t i;
		for (i = event_list_begin(events[worker]);
		     i != event_list_end(events[worker]);
		     i = event_list_next(i))
		{
			linesize++;
		}
		maxline = MAX(maxline, linesize);
	}

	unsigned i;
	for (i = 0; i < maxline + 1; i++)
	{
		fprintf(output, "bla\t");
	}
	fprintf(output,"\n");


	for (worker = 0; worker < nworkers; worker++)
	{
		unsigned long prev = start_time;

		fprintf(output, "%lu\t", 0 / FACTOR);

		event_itor_t i;
		for (i = event_list_begin(events[worker]);
		     i != event_list_end(events[worker]);
		     i = event_list_next(i))
		{
			fprintf(output, "%lu\t", (i->time - prev)/FACTOR);
			prev = i->time;
		}
		fprintf(output, "\n");
	}

	fclose(output);
}

/*
 * This program should be used to parse the log generated by FxT 
 */
int main(int argc, char **argv)
{
	char *filename, *filenameout;
	int ret;
	int fd_in, fd_out;
	
	if (argc < 2) {
	        fprintf(stderr, "Usage : %s input_filename [-o output_filename]\n", argv[0]);
	        exit(-1);
	}
	
	filename = argv[1];

	fd_in = open(filename, O_RDONLY);
	if (fd_in < 0) {
	        perror("open failed :");
	        exit(-1);
	}
	
	fut = fxt_fdopen(fd_in);
	if (!fut) {
	        perror("fxt_fdopen :");
	        exit(-1);
	}
	
	fxt_blockev_t block;
	block = fxt_blockev_enter(fut);

	/* create a htable to identify each worker(tid) */
	hcreate(MAXWORKERS);

	taskq = workq_list_new();

	while(1) {
		ret = fxt_next_ev(block, FXT_EV_TYPE_64, (struct fxt_ev *)&ev);
		if (ret != FXT_EV_OK) {
			fprintf(stderr, "no more block ...\n");
			break;
		}

		int nbparam = ev.nb_params;

		if (first_event)
		{
			first_event = 0;
			start_time = ev.time;
		}

		switch (ev.code) {
			case FUT_NEW_WORKER_KEY:
				handle_new_worker();
				break;
			case FUT_START_CODELET_BODY:
				handle_start_codelet_body();
				break;
			case FUT_END_CODELET_BODY:
				handle_end_codelet_body();
				break;
			case FUT_JOB_PUSH:
				handle_job_push();
				break;
			case FUT_JOB_POP:
				handle_job_pop();
				break;
			default:
				fprintf(stderr, "unknown event.. %x at time %llx\n", ev.code, ev.time);
				break;
		}
	}

	generate_gnuplot_output();
	generate_flash_output();

	return 0;
}
