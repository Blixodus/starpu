#include <stdint.h>
#include "comp_cuda.h"
#include "jobs.h"

#define MATA(x,y)	(datamatA[(x)+(y)*widthA])
#define MATB(x,y)	(datamatB[(x)+(y)*widthB])
#define MATC(x,y)	(datamatC[(x)+(y)*widthC])

#if 0

extern "C"
__global__ void 
cuda_dummy_mult
(
	uint32_t * datamatA, unsigned widthA, unsigned xaA, unsigned xbA, unsigned yaA, unsigned ybA,
	uint32_t *datamatB, unsigned widthB, unsigned xaB, unsigned xbB, unsigned yaB, unsigned ybB,
	uint32_t *datamatC, unsigned widthC, unsigned xaC, unsigned xbC, unsigned yaC, unsigned ybC)
{	
	/* we assume that size are ok for multiplication ...XXX  */
	/* XXX assert ybB - yaB == xbA - xaA */ 

	unsigned x,y,z;
	int sum;

	int width = xbC - xaC;
	int heigth = ybC - yaC;
	int depth = xbA - xaA;


	for (x = 0; x < width ; x++) 
	{
		for (y = 0 ; y < heigth; y++)
		{
			sum = 0;
			for (z = 0 ; z < depth ; z++) 
			{
				sum += MATA(xaA+z,yaA+y) * MATB(xaB+x,yaB + z);
			} 
			MATC(xaC + x,yaC + y) = sum;
		}
	}

	return;
}

#endif // 0

#define DEBUG

#if 0

extern "C"
__global__ void 
cuda_coherent_mult
(
	int * datamatA, unsigned widthA, unsigned xaA, unsigned xbA, unsigned yaA, unsigned ybA,
	uint32_t *datamatB, unsigned widthB, unsigned xaB, unsigned xbB, unsigned yaB, unsigned ybB,
	uint32_t *datamatC, unsigned widthC, unsigned xaC, unsigned xbC, unsigned yaC, unsigned ybC
#ifdef DEBUG
	, int *toto
#endif
	)
{	
	/* we assume that size are ok for multiplication ...XXX  */
	/* XXX assert ybB - yaB == xbA - xaA */ 

	unsigned x,y,z;
	uint32_t sum;

	int width = UPDIV( xbC - xaC, gridDim.x );
	int heigth = UPDIV( ybC - yaC, gridDim.y );
	int depth = xbA - xaA;

	int startx = MIN(blockIdx.x*width + threadIdx.x,  xbC - xaC);
	int starty = MIN(blockIdx.y*heigth, ybC - yaC);

	int endx   = MIN((blockIdx.x+1)*width,  xbC - xaC); 
	int endy   = MIN((blockIdx.y+1)*heigth, ybC - yaC);

	for (y = starty ; y < endy; y++)
	{
		for (x = startx; x < endx ; x+= blockDim.x) 
		{
			sum = 0;
			for (z = 0 ; z < depth ; z++) 
			{
				sum += MATA(xaA+z,yaA+y) * MATB(xaB+x,yaB + z);
			} 
			MATC(xaC + x,yaC + y) = sum;
		}
	}

	*toto = heigth;

	return;
}

#endif // 0

#define CHUNCKDEPTH	128 

__shared__ uint32_t *Achunk;
__shared__ uint32_t *Bchunk;

extern "C"
__global__ void 
cuda_mult
(
	int * datamatA, unsigned widthA, unsigned xaA, unsigned xbA, unsigned yaA, unsigned ybA,
	uint32_t *datamatB, unsigned widthB, unsigned xaB, unsigned xbB, unsigned yaB, unsigned ybB,
	uint32_t *datamatC, unsigned widthC, unsigned xaC, unsigned xbC, unsigned yaC, unsigned ybC
#ifdef DEBUG
	,int *toto
#endif
)
{	
	/* we assume that size are ok for multiplication ...XXX  */
	/* XXX assert ybB - yaB == xbA - xaA */ 

	unsigned x,y,z;
	uint32_t sum;

	int width = UPDIV( xbC - xaC , blockDim.x * gridDim.x );
	int heigth = UPDIV( ybC - yaC , blockDim.y * gridDim.y );
	int depth = xbA - xaA;

	unsigned tidx = threadIdx.x + blockIdx.x * blockDim.x; 
	unsigned tidy = threadIdx.y + blockIdx.y * blockDim.y; 

	int startx = MIN(tidx*width,  xbC - xaC);
	int starty = MIN(tidy*heigth, ybC - yaC);

	int endx   = MIN((tidx+1)*width,  xbC - xaC); 
	int endy   = MIN((tidy+1)*heigth, ybC - yaC);


	/* first create local buffers ... */
	__shared__ uint32_t Achunk[CHUNCKDEPTH*heigth];
	__shared__ uint32_t Bchunk[width*CHUNCKDEPTH];
	__shared__ uint32_t Cchunk[width*heigth];

	/* zero the Cchunk ... */
	int i;
	for (i = 0; i < width*heigth; i++)
	{
		Cchunk[i] = 0;
	}


//	for (x = startx; x < endx ; x++) 
//	{
//		for (y = starty ; y < endy; y++)
//		{
//			sum = 0;
//			for (z = 0 ; z < depth ; z++) 
//			{
//				sum += MATA(xaA+z,yaA+y) * MATB(xaB+x,yaB + z);
//			} 
//			MATC(xaC + x,yaC + y) = sum;
//		}
//	}

	for (z = 0 ; z < depth ; z+= CHUNCKDEPTH) 
	{
		
	}

	*toto = 1664;

	return;
}


