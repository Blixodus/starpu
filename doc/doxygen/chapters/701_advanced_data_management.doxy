/* StarPU --- Runtime system for heterogeneous multicore architectures.
 *
 * Copyright (C) 2009-2022  Universit√© de Bordeaux, CNRS (LaBRI UMR 5800), Inria
 *
 * StarPU is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or (at
 * your option) any later version.
 *
 * StarPU is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * See the GNU Lesser General Public License in COPYING.LGPL for more details.
 */

/*! \page AdvancedDataManagement Advanced Data Management

\section ManualPartitioning Manual Partitioning

Except the partitioning functions described in \ref PartitioningData and \ref AsynchronousPartitioning,
one can also handle partitioning by hand, by registering several views on the
same piece of data. The idea is then to manage the coherency of the various
views through the common buffer in the main memory.
<c>fmultiple_manual</c> is a complete example using this technique.

In short, we first register the same matrix several times:

\code{.c}
starpu_matrix_data_register(&handle, STARPU_MAIN_RAM, (uintptr_t)matrix, NX, NX, NY, sizeof(matrix[0]));

for (i = 0; i < PARTS; i++)
    starpu_matrix_data_register(&vert_handle[i], STARPU_MAIN_RAM, (uintptr_t)&matrix[0][i*(NX/PARTS)], NX, NX/PARTS, NY, sizeof(matrix[0][0]));
\endcode

Since StarPU is not aware that the two handles are actually pointing to the same
data, we have a danger of inadvertently submitting tasks to both views, which
will bring a mess since StarPU will not guarantee any coherency between the two
views.  To make sure we don't do this, we invalidate the view that we will not
use:

\code{.c}
for (i = 0; i < PARTS; i++)
    starpu_data_invalidate(vert_handle[i]);
\endcode

Then we can safely work on <c>handle</c>.

When we want to switch to the vertical slice view, all we need to do is bring
coherency between them by running an empty task on the home node of the data:

\code{.c}
struct starpu_codelet cl_switch =
{
    .where = STARPU_NOWHERE,
    .nbuffers = 3,
    .specific_nodes = 1,
    .nodes = { STARPU_MAIN_RAM, STARPU_MAIN_RAM, STARPU_MAIN_RAM },
};

ret = starpu_task_insert(&cl_switch, STARPU_RW, handle,
            STARPU_W, vert_handle[0],
            STARPU_W, vert_handle[1],
            0);
\endcode

The execution of the task <c>switch</c> will get back the matrix data into the
main memory, and thus the vertical slices will get the updated value there.

Again, we prefer to make sure that we don't accidentally access the matrix through the whole-matrix handle:

\code{.c}
starpu_data_invalidate_submit(handle);
\endcode

Note: when enabling a set of handles in this way, the set must not have any
overlapping, i.e. the handles of the set must not have any part of data in
common, otherwise StarPU will not properly handle concurrent accesses between
them.

And now we can start using vertical slices, etc.

\section DefiningANewDataFilter Defining A New Data Filter

StarPU provides a series of predefined filters in \ref API_Data_Partition, but
additional filters can be defined by the application. The principle is that the
filter function just fills the memory location of the <c>i-th</c> subpart of a data.
Examples are provided in <c>src/datawizard/interfaces/*_filters.c</c>,
check \ref starpu_data_filter::filter_func for further details.
The helper function starpu_filter_nparts_compute_chunk_size_and_offset() can be used to
compute the division of pieces of data.

\section DefiningANewDataInterface Defining A New Data Interface

This section proposes an example how to define your own interface, when the
StarPU-provided interface do not fit your needs. Here we take a dumb example of
an array of complex numbers represented by two arrays of double values.

Let's thus define a new data interface to manage arrays of complex numbers:

\code{.c}
/* interface for complex numbers */
struct starpu_complex_interface
{
        double *real;
        double *imaginary;
        int nx;
};
\endcode

That structure stores enough to describe <b>one</b> buffer of such kind of
data. It is used for the buffer stored in the main memory, another instance
is used for the buffer stored in a GPU, etc. A <i>data handle</i> is thus a
collection of such structures, to describe each buffer on each memory node.

Note: one should not make pointers that point into such structures, because
StarPU needs to be able to copy over the content of it to various places, for
instance to efficiently migrate a data buffer from one data handle to another
data handle, so the actual address of the structure may vary.

\subsection DefiningANewDataInterface_registration Data registration

Registering such a data to StarPU is easily done using the function
starpu_data_register(). The last
parameter of the function, <c>interface_complex_ops</c>, will be
described below.

\code{.c}
void starpu_complex_data_register(starpu_data_handle_t *handleptr,
     unsigned home_node, double *real, double *imaginary, int nx)
{
        struct starpu_complex_interface complex =
        {
                .real = real,
                .imaginary = imaginary,
                .nx = nx
        };

        if (interface_complex_ops.interfaceid == STARPU_UNKNOWN_INTERFACE_ID)
        {
                interface_complex_ops.interfaceid = starpu_data_interface_get_next_id();
        }

        starpu_data_register(handleptr, home_node, &complex, &interface_complex_ops);
}
\endcode

The <c>struct starpu_complex_interface complex</c> is here used just to store the
parameters that the user provided to <c>starpu_complex_data_register</c>.
starpu_data_register() will first allocate the handle, and
then pass the structure <c>starpu_complex_interface</c> to the method
starpu_data_interface_ops::register_data_handle, which records them
within the data handle (it is called once per node by starpu_data_register()):

\code{.c}
static void complex_register_data_handle(starpu_data_handle_t handle, int home_node, void *data_interface)
{
    struct starpu_complex_interface *complex_interface = (struct starpu_complex_interface *) data_interface;

    unsigned node;
    for (node = 0; node < STARPU_MAXNODES; node++)
    {
        struct starpu_complex_interface *local_interface = (struct starpu_complex_interface *)
            starpu_data_get_interface_on_node(handle, node);

        local_interface->nx = complex_interface->nx;
        if (node == home_node)
        {
            local_interface->real = complex_interface->real;
            local_interface->imaginary = complex_interface->imaginary;
        }
        else
        {
            local_interface->real = NULL;
            local_interface->imaginary = NULL;
        }
    }
}
\endcode

If the application provided a home node, the corresponding pointers will be
recorded for that node. Others have no buffer allocated yet.
Possibly the interface needs some dynamic allocation (e.g. to store an array of
dimensions that can have variable size). The corresponding deallocation will then be
done in starpu_data_interface_ops::unregister_data_handle.

Different operations need to be defined for a data interface through
the type starpu_data_interface_ops. We only define here the basic
operations needed to run simple applications. The source code for the
different functions can be found in the file
<c>examples/interface/complex_interface.c</c>, the details of the hooks to be
provided are documented in \ref starpu_data_interface_ops .

\code{.c}
static struct starpu_data_interface_ops interface_complex_ops =
{
        .register_data_handle = complex_register_data_handle,
        .allocate_data_on_node = complex_allocate_data_on_node,
        .copy_methods = &complex_copy_methods,
        .get_size = complex_get_size,
        .footprint = complex_footprint,
        .interfaceid = STARPU_UNKNOWN_INTERFACE_ID,
        .interface_size = sizeof(struct starpu_complex_interface),
};
\endcode

Convenience functions can defined to access the different fields of the
complex interface from a StarPU data handle after a call to starpu_data_acquire():

\code{.c}
double *starpu_complex_get_real(starpu_data_handle_t handle)
{
        struct starpu_complex_interface *complex_interface =
          (struct starpu_complex_interface *) starpu_data_get_interface_on_node(handle, STARPU_MAIN_RAM);
        return complex_interface->real;
}

double *starpu_complex_get_imaginary(starpu_data_handle_t handle);
int starpu_complex_get_nx(starpu_data_handle_t handle);
\endcode

Similar functions need to be defined to access the different fields of the
complex interface from a <c>void *</c> pointer to be used within codelet
implemetations.

\snippet complex.c To be included. You should update doxygen if you see this text.

Complex data interfaces can then be registered to StarPU.

\code{.c}
double real = 45.0;
double imaginary = 12.0;
starpu_complex_data_register(&handle1, STARPU_MAIN_RAM, &real, &imaginary, 1);
starpu_task_insert(&cl_display, STARPU_R, handle1, 0);
\endcode

and used by codelets.

\code{.c}
void display_complex_codelet(void *descr[], void *_args)
{
        int nx = STARPU_COMPLEX_GET_NX(descr[0]);
        double *real = STARPU_COMPLEX_GET_REAL(descr[0]);
        double *imaginary = STARPU_COMPLEX_GET_IMAGINARY(descr[0]);
        int i;

        for(i=0 ; i<nx ; i++)
        {
                fprintf(stderr, "Complex[%d] = %3.2f + %3.2f i\n", i, real[i], imaginary[i]);
        }
}
\endcode

The whole code for this complex data interface is available in the
directory <c>examples/interface/</c>.


\subsection DefiningANewDataInterface_allocation Data allocation

To be able to run tasks on GPUs etc. StarPU needs to know how to allocate a
buffer for the interface. In our example, two allocations are needed in the
allocation method \c complex_allocate_data_on_node(): one for the real part and one
for the imaginary part.

\code{.c}
static starpu_ssize_t complex_allocate_data_on_node(void *data_interface, unsigned node)
{
    struct starpu_complex_interface *complex_interface = (struct starpu_complex_interface *) data_interface;

    double *addr_real = NULL;
    double *addr_imaginary = NULL;
    starpu_ssize_t requested_memory = complex_interface->nx * sizeof(complex_interface->real[0]);

    addr_real = (double*) starpu_malloc_on_node(node, requested_memory);
    if (!addr_real)
        goto fail_real;
    addr_imaginary = (double*) starpu_malloc_on_node(node, requested_memory);
    if (!addr_imaginary)
        goto fail_imaginary;

    /* update the data properly in consequence */
    complex_interface->real = addr_real;
    complex_interface->imaginary = addr_imaginary;

    return 2*requested_memory;

fail_imaginary:
    starpu_free_on_node(node, (uintptr_t) addr_real, requested_memory);
fail_real:
    return -ENOMEM;
}
\endcode

Here we try to allocate the two parts. If either of them fails, we return
\c -ENOMEM. If they succeed, we can record the obtained pointers and returned the
amount of allocated memory (for memory usage accounting).

Conversely, \c complex_free_data_on_node() frees the two parts:

\code{.c}
static void complex_free_data_on_node(void *data_interface, unsigned node)
{
    struct starpu_complex_interface *complex_interface = (struct starpu_complex_interface *) data_interface;
    starpu_ssize_t requested_memory = complex_interface->nx * sizeof(complex_interface->real[0]);

    starpu_free_on_node(node, (uintptr_t) complex_interface->real, requested_memory);
    starpu_free_on_node(node, (uintptr_t) complex_interface->imaginary, requested_memory);
}
\endcode

We we have not made anything particular for GPUs or whatsoever: it is
starpu_free_on_node() which knows how to actually make the allocation, and
returns the resulting pointer, be it in main memory, in GPU memory, etc.

\subsection DefiningANewDataInterface_copy Data copy

Now that StarPU knows how to allocate/free a buffer, it needs to be able to
copy over data into/from it. Defining a method \c copy_any_to_any() allows StarPU to
perform direct transfers between main memory and GPU memory.

\code{.c}
static int copy_any_to_any(void *src_interface, unsigned src_node,
               void *dst_interface, unsigned dst_node,
               void *async_data)
{
    struct starpu_complex_interface *src_complex = src_interface;
    struct starpu_complex_interface *dst_complex = dst_interface;
    int ret = 0;


    if (starpu_interface_copy((uintptr_t) src_complex->real, 0, src_node,
                    (uintptr_t) dst_complex->real, 0, dst_node,
                     src_complex->nx*sizeof(src_complex->real[0]),
                     async_data))
        ret = -EAGAIN;
    if (starpu_interface_copy((uintptr_t) src_complex->imaginary, 0, src_node,
                    (uintptr_t) dst_complex->imaginary, 0, dst_node,
                     src_complex->nx*sizeof(src_complex->imaginary[0]),
                     async_data))
        ret = -EAGAIN;
    return ret;
}
\endcode

We here again have no idea what is main memory or GPU memory, or even if the
copy is synchronous or asynchronous: we just call starpu_interface_copy()
according to the interface, passing it the pointers, and checking whether it
returned \c -EAGAIN, which means the copy is asynchronous, and StarPU will
appropriately wait for it thanks to the pointer \c async_data.

This copy method is referenced in a structure \ref starpu_data_copy_methods

\code{.c}
static const struct starpu_data_copy_methods complex_copy_methods =
{
    .any_to_any = copy_any_to_any
};
\endcode

which was referenced in the structure \ref starpu_data_interface_ops above.

Other fields of \ref starpu_data_copy_methods allow to provide optimized
variants, notably for the case of 2D or 3D matrix tiles with non-trivial ld.

\subsection DefiningANewDataInterface_pack Data pack/peek/unpack

The copy methods allow for RAM/GPU transfers, but is not enough for e.g.
transferring over MPI. That requires defining the pack/peek/unpack methods. The
principle is that the method starpu_data_interface_ops::pack_data concatenates
the buffer data into a newly-allocated contiguous bytes array, conversely
starpu_data_interface_ops::peek_data extracts from a bytes array into the
buffer data, and starpu_data_interface_ops::unpack_data does the same as
starpu_data_interface_ops::peek_data but also frees the bytes array.

\code{.c}
static int complex_pack_data(starpu_data_handle_t handle, unsigned node, void **ptr, starpu_ssize_t *count)
{
    STARPU_ASSERT(starpu_data_test_if_allocated_on_node(handle, node));

    struct starpu_complex_interface *complex_interface = (struct starpu_complex_interface *)
        starpu_data_get_interface_on_node(handle, node);

    *count = complex_get_size(handle);
    if (ptr != NULL)
    {
        char *data;
        data = (void*) starpu_malloc_on_node_flags(node, *count, 0);
        *ptr = data;
        memcpy(data, complex_interface->real, complex_interface->nx*sizeof(double));
        memcpy(data+complex_interface->nx*sizeof(double), complex_interface->imaginary, complex_interface->nx*sizeof(double));
    }

    return 0;
}
\endcode

\c complex_pack_data() first computes the size to be allocated, then allocates it,
and copies over into it the content of the two real and imaginary arrays.

\code{.c}
static int complex_peek_data(starpu_data_handle_t handle, unsigned node, void *ptr, size_t count)
{
    char *data = ptr;
    STARPU_ASSERT(starpu_data_test_if_allocated_on_node(handle, node));

    struct starpu_complex_interface *complex_interface = (struct starpu_complex_interface *)
        starpu_data_get_interface_on_node(handle, node);

    STARPU_ASSERT(count == 2 * complex_interface->nx * sizeof(double));
    memcpy(complex_interface->real, data, complex_interface->nx*sizeof(double));
    memcpy(complex_interface->imaginary, data+complex_interface->nx*sizeof(double), complex_interface->nx*sizeof(double));

    return 0;
}
\endcode

\c complex_peek_data() simply uses \c memcpy() to copy over from the bytes array into the data buffer.

\code{.c}
static int complex_unpack_data(starpu_data_handle_t handle, unsigned node, void *ptr, size_t count)
{
    complex_peek_data(handle, node, ptr, count);

    starpu_free_on_node_flags(node, (uintptr_t) ptr, count, 0);

    return 0;
}
\endcode

And \c complex_unpack_data() just calls \c complex_peek_data() and releases the bytes array.

\subsection DefiningANewDataInterface_pointers Pointers inside the data interface

In the example described above, the two pointers stored in the data interface
are data buffers, which may point into main memory GPU memory, etc. One may also
want to store pointers to meta-data for the interface, for instance the list of
dimensions sizes for the n-dimension matrix interface, but such pointers are to
be handled completely differently.

More precisely, there are two types of pointers:

<ul>
<li>Data pointers, which point to the actual data in RAM/GPU/etc. memory. They
may be NULL when the data is not allocated (yet). StarPU will automatically
call starpu_data_interface_ops::allocate_data_on_node to allocate the data
pointers whenever needed, and call starpu_data_interface_ops::free_data_on_node
when memory gets scarce.  For instance, for the n-dimension matrix interface
the pointers to the actual data (\c ptr, \c dev_handle, \c offset) are data
pointers.

<li>Meta-data pointers, which always point to RAM memory. They are usually
always allocated so that they can always be used. For instance, for the
n-dimension matrix interface the array of dimension sizes and the array of ld
are meta-data pointers.
</ul>

This means that:

<ul>
<li>The starpu_data_interface_ops::register_data_handle method has to allocate
the meta-data pointers. If the user provided a buffer for the initial value
of the handle, starpu_data_interface_ops::register_data_handle sets the data
pointers of the home_node interface to that buffer.
<li>The interface can additionally provide a \c ptr_register helper to set the
data pointer of a given node.
<li>The starpu_data_interface_ops::unregister_data_handle method has to
deallocate the meta-data pointers
<li>The starpu_data_interface_ops::allocate_data_on_node method has to allocate
the data pointers on the given node.
<li>The starpu_data_interface_ops::free_data_on_node method has to deallocate
the data pointers on the given node.
<li>The starpu_data_interface_ops::reuse_data_on_node transfers the data
pointers from a cached interface to the destination interface.
<li>The starpu_data_interface_ops::map_data has to map the data pointers on the
given node.
<li>The starpu_data_interface_ops::unmap_data has to unmap the data pointers on
the given node.
<li>The filtering functions have to allocate the meta-data pointers for the
child interface, and when the parent interface has data pointers, it has to set
the child data pointers to point into the parent data buffers.
</ul>

Note: for compressed matrices such as CSR, BCSR, COO, the \c colind and \c
rowptr arrays are not meta-data pointers, but data pointers like \c nzval,
because they need to be available in GPU memory for the GPU kernels.

Note: when the interface does not contain meta-data pointers,
starpu_data_interface_ops::reuse_data_on_node does not need to
be implemented, StarPU will just use a memcpy. Otherwise, either
starpu_data_interface_ops::reuse_data_on_node must be used to transfer only the
data pointers and not the meta-data pointers, or the allocation cache should be
disabled by setting starpu_data_interface_ops::dontcache to 1.

Note: It should be noted that because of the allocation cache,
starpu_data_interface_ops::free_data_on_node may be called on an interface which
is not attached to a handle any more. This means that the meta-data pointers
will have been deallocated by starpu_data_interface_ops::unregister_data_handle,
and cannot be used by starpu_data_interface_ops::free_data_on_node to e.g.
compute the size to be deallocated. For instance, the n-dimension matrix
interface uses an additional scalar allocsize field to store the allocation
size, thus still available even when the interface is in the allocation cache.

*/